---
title: "Example use of MixedUpSlimSims package"
format: 
  html:
    embed-resources: true
    df-print: kable
engine: knitr

---

Note, this currently uses files in the repository that are not part of the repository,
so it has to be run in the top level of the repo.


## Initial set up

See the readme about configuring your system to be able to run this.

After that you can get started.

```{r}
#| message: false
library(reticulate)
library(tidyverse)
library(MixedUpSlimSims)

```

## Making allele frequencies

I don't have the files that Jared used to get the allele frequencies.  That is OK.
I am going to just make one species 0.9 at a bunch of markers and the other 0.1 at the
same markers.  This will let us verify that things are correct according to admixture
fractions easily.

We will do 2000 markers spread throughout the genome. The package has a data object,
`mykiss_chroms` that looks like this:
```{r}
mykiss_chroms %>% head()
```
that we can use to get the total length of the genome.  Note that this sort of
input tibble can be used to do everything with other genomes.

I generalized the genotype making function to take any number of populations. Also,
it seems not good to initialize the simulation with just 5 founders in one of the populations.
I just choose to initialize with 1000 individuals in each.

Here we make our allele freqs at random positions
```{r}
set.seed(1)
frqs <- tibble(
  POS = sort(runif(2000, min = 1, max = max(mykiss_chroms$cumul_end)))
) %>%
  mutate(af1 = 0.1, af2 = 0.9)

# have a look at that
frqs %>% head()
```

Now, I have modified the SLiM script to be a little more generic for testing. It looks
like this:
```{cpp filename="Listing of SLiM-models/2-pop-10-gens-vcf-initialize.slim"}
#| eval: false
#| file: ./SLiM-models/2-pop-10-gens-vcf-initialize.slim
```

From that, you can see that we want to write our file to `slim_input.vcf`.  So,
simulate 1000 indivs for each population and then write it out.
```{r}
frqs %>%
  simulate_founder_genos(N = c(1000, 1000), pop_names = c("rbt", "wct")) %>%
  write_input_vcf(out_path = "slim_input.vcf") 
```


## Running SLiM

We can just run this dude from here.  We will use a system call, though we could
have run it in a shell block.
```{r}
system("slim -s 333 SLiM-models/2-pop-10-gens-vcf-initialize.slim")
```

That seemed to work fine, and it wrote out some files:
```{r}
dir(pattern = "p[0-9]+-[0-9]+\\.vcf")
```

## Processing the trees

There are 11 years of simulation, so we want to get things for tree-seq years
0 to 10 from populations 1 and 2. We do that like this:
```{r}
# read the trees. Dump just captures the python code that was
# evaluated to get things in the py variable in the global env.
dump <- read_and_filter_trees(
  trees_path = "SLiM.trees",
  years_list = list(`1` = 0:10, `2` = 0:10)
)

```


Now that we have read and simplified that tree into the `py$ts` object,
we can turn it into tibbles of nodes and indivs easily:
```{r}
ni <- ts_nodes_and_inds(py$ts)
```

Now we get a vector of the founder nodes.  These are the ones
that existed at time 10 (counting backwards from 0) in TS time,
which is time 1 in SLiM time.
```{r}
founders <- founder_node_ids_and_pops(ni, 10)
```

Now we want to get the focal nodes.  These could be just the individuals
in the final three generations, but I want to plot pictures of the admixture
process in action, so I am going to make the focal individuals everyone
in SLiM year 2 and forward (so, TS time 9 and forward to 0), in both pops 1 and 2.
We designate the desired years and pops in a tibble.  However, remember that in
tskit, the populations are base-0 indexed.  So our tibble will look like this:
```{r}
focal_tibble <- tibble(
  pop = rep(c(1,2), each = 10),
  time = rep(0:9, 2)
)

focal_tibble
```

And we can use it in here like so:
```{r}
fnl <- get_focal_nodes(
  ni, 
  Focal = focal_tibble
)
```

Note that `fnl` has these focal nodes divided into different years, and the following
function cycles over those years and found ancestors for each separately, because
otherwise some samples become the linked ancestors (in `link_ancestors` from tskit),
which is not what we want here.

Now we get the ancestral segments in all of them.
```{r}
segments_tib <- ancestral_segs(
  ts = py$ts,
  focal_nodes_list = fnl,
  founder_nodes = founders$nodes,
  nodes_tib = ni$nodes_tib,
  indiv_tib = ni$indiv_tib
)
```


## Plotting the haploid ancestry segments

This is done with a simple function:
```{r}
#| fig-height: 10
#| fig-width: 8
plot_ancestry_of_genomes(segments_tib)
```


## Obtaining and plotting the ancestry tracts within each individual

There is a function for this:
```{r}
#| message: false
indiv_segs <- indiv_ancestry_tracts(segments_tib)
```

And we can plot those like this:
```{r}
#| fig-height: 10
#| fig-width: 8
plot_ancestry_tracts(indiv_segs, chrom_ends = mykiss_chroms)
```

The colors denote the different ancestry combinations, which are coded in decimal
equivalents of trits or ternary numbers.  2 = 2 doses from p1; 4 = 1 dose from p1
and one from p2; 6 is two doses from p2.  This can extend to more than two
species.



## Calculating admixture fractions from the ancestry tracts

This is easily done.
```{r}
Q_values <- admixture_fracts_from_ancestry_tracts(indiv_segs)
```

And, for fun, we can plot histograms of the Q-values over time in the two populations
```{r}
#| fig-height: 10
#| fig-width: 8
Q_values %>%
  mutate(time_f = factor(ind_time, levels = rev(sort(unique(ind_time))))) %>%
  ggplot() +
  geom_histogram(aes(x = admix_fract, fill = factor(anc_pop)), alpha = 0.8, bins = 50) +
  facet_grid(time_f ~ ind_pop, scales = "free_y") +
  theme_bw()
```

Yep, that looks about right.

## Getting into the VCFs

