// The population sizes and migration rates below, along with the right ms demographic parameters in the python parsing script, give similar MAF distributions as the Cyclone empirical data

initialize() {
	defineConstant("analysis_pop", "McGee"); // define the analysis population
	defineConstant("n_rbt", 5); // number of "pure" RBT for the specific stream: Cyclone = 3, Langford = 47, McGee = 5
	defineConstant("n_wct", 130); // number of "pure" WCT for the specific stream: Cyclone = 2250, Langford = 319, McGee = 130
	defineConstant("curr_pop_size", 1000); // number of individuals in current RBT and WCT populations
	defineConstant("n_offsp_sampled", 100); // number of offspring to sample in each of current RBT and WCT populations	
	
	initializeSLiMOptions(keepPedigrees=T); // turn on pedigree tracking; see section 25 of the manual (25.7, pg. 679)
	defineConstant("L", 1949962539); // length of genome
	initializeTreeSeq();
	initializeMutationRate(0); // zero mutations forward-in-time; will be added by msprime afterwards
	initializeMutationType("m1", 0.5, "f", 0.0); // neutral mutations
	m1.convertToSubstitution = F; // keep loci in the simulation, even if they reach fixation
	initializeGenomicElementType("g1", m1, 1.0);
	initializeGenomicElement(g1, 0, L);
	
	 // set up 29 trout chromosomes with not much recombination within them
    ends = c(84884017, 84884018, 170364868, 170364869, 255302337, 255302338, 340358758, 340358759, 432561311, 432561312, 515492034, 515492035, 595255810, 595255811, 679034094, 679034095, 747501830, 747501831, 818558021, 818558022, 898836325, 898836326, 988491333, 988491334, 1054543576, 1054543577, 1134902301, 1134902302, 1198270468, 1198270469, 1269166547, 1269166548, 1345694384, 1345694385, 1407413604, 1407413605, 1466989977, 1466989978, 1508401989, 1508401990, 1560331576, 1560331577, 1608881719, 1608881720, 1657923568, 1657923569, 1698286047, 1698286048, 1780887703, 1780887704, 1821070223, 1821070224, 1866387099, 1866387100, 1907331003, 1907331004, 1949962539);
    rates = c(1e-09, 0.5, 1e-09, 0.5, 1e-09, 0.5, 1e-09, 0.5, 1e-09, 0.5, 1e-09, 0.5, 1e-09, 0.5, 1e-09, 0.5, 1e-09, 0.5, 1e-09, 0.5, 1e-09, 0.5, 1e-09, 0.5, 1e-09, 0.5, 1e-09, 0.5, 1e-09, 0.5, 1e-09, 0.5, 1e-09, 0.5, 1e-09, 0.5, 1e-09, 0.5, 1e-09, 0.5, 1e-09, 0.5, 1e-09, 0.5, 1e-09, 0.5, 1e-09, 0.5, 1e-09, 0.5, 1e-09, 0.5, 1e-09, 0.5, 1e-09, 0.5, 1e-09);
    initializeRecombinationRate(rates, ends);
    initializeSex("A"); //Make all chromosomes autosomal
}
1 late() {
	//make two pops, with ongoing gene flow until the end of the simulation
	sim.addSubpop("p1", n_rbt); // rainbow trout population
	sim.addSubpop("p2", n_wct); // westslope population
	
	c(p1,p2).genomes.readFromVCF("/Users/jaredgrummer/Documents/UM/Research_Documents/Hybrid_Simulations/Simulated_vcf_files/" + analysis_pop + "_slim_input.vcf", m1); // Read in a .vcf that was made in R and has RBT individuals first and WCT individuals second
	
		// I ran p1.genomes.outputVCF() right here, and the data seem to be getting read in correctly and placed in the right subpopulations!
	
	sim.treeSeqRememberIndividuals(sim.subpopulations.individuals); // retains first-gen p1 and p2 individuals to determine genomic region population-of-origin; automatically recorded by default, but doesn't hurt to keep explicitly
	p1.setSubpopulationSize(1000); // bump up RBT pop. size
	p2.setSubpopulationSize(1000); // bump up WCT pop. size
	p1.setMigrationRates(p2, 0.05); // migration rate from WCT into RBT
	p2.setMigrationRates(p1, 0.01); // migration rate from RBT into WCT
}
9 late() {
	sim.treeSeqRememberIndividuals(sim.subpopulations.individuals); // retains individual information so we can get their data as grandparents of the final generation
	p1.outputVCFSample(curr_pop_size, replace=F, filePath="/Users/jaredgrummer/Documents/UM/Research_Documents/Hybrid_Simulations/Simulated_vcf_files/" + analysis_pop + "_rbt_grandparents_slim_output.vcf"); // write out a .vcf of all the individuals in the grandparental generation of RBT populuation
	p2.outputVCFSample(curr_pop_size, replace=F, filePath="/Users/jaredgrummer/Documents/UM/Research_Documents/Hybrid_Simulations/Simulated_vcf_files/" + analysis_pop + "_wct_grandparents_slim_output.vcf"); // write out a .vcf of all the individuals in the grandparental generation of WCT populuation

}
10 late() {
	sim.treeSeqRememberIndividuals(sim.subpopulations.individuals); // retains individual information so we can get their data as parents of the final generation
	p1.outputVCFSample(curr_pop_size, replace=F, filePath="/Users/jaredgrummer/Documents/UM/Research_Documents/Hybrid_Simulations/Simulated_vcf_files/" + analysis_pop + "_rbt_parents_slim_output.vcf"); // write out a .vcf of all the individuals in the parental generation of RBT populuation
	p2.outputVCFSample(curr_pop_size, replace=F, filePath="/Users/jaredgrummer/Documents/UM/Research_Documents/Hybrid_Simulations/Simulated_vcf_files/" + analysis_pop + "_wct_parents_slim_output.vcf"); // write out a .vcf of all the individuals in the parental generation of WCT populuation
	
}
11 late() {
	sim.treeSeqOutput("/Users/jaredgrummer/Documents/UM/Research_Documents/Hybrid_Simulations/Simulated_vcf_files/" + analysis_pop + ".trees"); // after 30 gens of mixing/interbreeding, write out trees
	p1.outputVCFSample(n_offsp_sampled, replace=F, filePath="/Users/jaredgrummer/Documents/UM/Research_Documents/Hybrid_Simulations/Simulated_vcf_files/" + analysis_pop + "_rbt_offspring_slim_output.vcf"); // write out a .vcf of all the individuals in the grandparental generation of RBT populuation
	p2.outputVCFSample(n_offsp_sampled, replace=F, filePath="/Users/jaredgrummer/Documents/UM/Research_Documents/Hybrid_Simulations/Simulated_vcf_files/" + analysis_pop + "_wct_offspring_slim_output.vcf"); // write out a .vcf of all the individuals in the grandparental generation of WCT populuation
}

