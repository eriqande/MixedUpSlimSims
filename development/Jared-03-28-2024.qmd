---
title: "Jared's 03/28/2024 Version"
format: 
  html:
    embed-resources: true
engine: knitr

---

## Setup

Define the path to your pyslim conda environment, here.

```{r}
PYSLIM_CONDA <- normalizePath("~/mambaforge-x86_64/envs/pyslim")
```


## Run SLiM


We can run it like this:
```{sh}
#| output: false
slim -s 111 SLiM-models/SLiM_30gen_model_240328_full_genome.slim
```

## Get Environment Set up

```{r}
#| message: false
#| warning: false
library(tidyverse)
library(reticulate)
use_condaenv(condaenv = PYSLIM_CONDA)
```


## Jared's Initial Python Parts

The stuff in the block below all runs pretty quickly. 

```{python}
import msprime, pyslim, tskit
import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
import warnings
import tspop

#Specify the number of individuals that were in the SLiM simulation
#To be used for removing non-necessary individuals from data tables
num_inds = 1000
num_genomes = num_inds * 2

#Suppress a warning that ticks and generations might be different (should be the same in our SLiM model)
warnings.simplefilter('ignore', msprime.TimeUnitsMismatchWarning)

#Read in the trees generated by SLiM
slim_trees = tskit.load("30_gens_full_genome.trees")
print("Just read in", len(slim_trees.trees()), "trees from SLiM")

#Recapitate the trees to give coalescence histories to tree roots/ancestors from SLiM
#Recapitate with ancestral migration between p1 (RBT) and p2 (WCT)
print("Now recapitating SLiM trees")
demography = msprime.Demography.from_tree_sequence(slim_trees)
for pop in demography.populations:
	# set their effective population sizes
	pop.initial_size = 1000



#Use this for tspop, to be able to track population chromosome ancestry to this point/generation
#See https://tspop.readthedocs.io/en/latest/simulationsetup.html for more details
demography.add_census(time=30.01)

demography.add_migration_rate_change(
	time = slim_trees.metadata['SLiM']['tick'],
	rate = 0.01, source = "p1", dest = "p2",
	#rate = 0.01, source = "pop_1", dest = "pop_2",
)
demography.add_migration_rate_change(
	time = slim_trees.metadata['SLiM']['tick'],
	rate = 0.01, source = "p2", dest = "p1",
	#rate = 0.01, source = "pop_2", dest = "pop_1",
)

recapitated_trees = pyslim.recapitate(
		slim_trees, demography = demography,
		recombination_rate = 1e-9,  #specifying "recombination_rate" might mean that there is no recombination??
		random_seed = 6
)

#Now overlay mutations onto the trees
print("Now overlaying mutations onto the recapitated trees")
mutated_trees = msprime.sim_mutations(
					recapitated_trees, rate = 1e-11,
					random_seed = 5,
					keep = True # rate per unit of sequence length, per unit of time; remove "random_seed" once model is working
)

### OUTPUT VCFs HERE ###

print("Now writing variants to a .vcf file")

''' # A way to output just a subset of individuals; good for testing 
#Get a list of the individuals alive at the last generation of the simulation
gen0 = pyslim.individuals_alive_at(mutated_trees, time=0)
rng = np.random.default_rng(seed = 1)
keep_indivs = rng.choice(gen0, 100, replace=False) #Used to write out a subset of the individuals below

#Get the SLIM IDs rather than TSK_### for the .vcf
slim_ids = [str(mutated_trees.individual(x).metadata["pedigree_id"]) for x in keep_indivs]
#slim_ids = [str(mutated_trees.individual(x).metadata["pedigree_id"]) for x in gen0]

with open("/Users/jaredgrummer/Documents/UM/Research_Documents/Hybrid_Simulations/SLiM/example_snps_full_genome.vcf", "w") as vcffile:
	mutated_trees.write_vcf(vcffile,
	#individuals = gen0,
	individuals = keep_indivs, # to write out a subset of the individuals
	individual_names = slim_ids) '''

#Output a .vcf that has all individuals from the last three generations

#Get a list of the individuals alive at the last generation of the simulation (= "offspring")
gen0 = pyslim.individuals_alive_at(mutated_trees, time=0)

#Get the SLIM IDs rather than TSK_### for the .vcf
gen0_ids = [str(mutated_trees.individual(x).metadata["pedigree_id"]) for x in gen0]


#Get a list of the individuals that are the parents of the last generation
gen1 = pyslim.individuals_alive_at(mutated_trees, time=1, stage="late")

#Get the SLIM IDs rather than TSK_### for the .vcf
gen1_ids = [str(mutated_trees.individual(x).metadata["pedigree_id"]) for x in gen1]


#Get a list of the individuals that are the grandparents of the last generation
gen2 = pyslim.individuals_alive_at(mutated_trees, time=2, stage="late")

#Get the SLIM IDs rather than TSK_### for the .vcf
gen2_ids = [str(mutated_trees.individual(x).metadata["pedigree_id"]) for x in gen2]

#Combine individual IDs from the last three generations
all_gens = np.concatenate((gen0, gen1, gen2))

#Combine the pedigree IDs from the last three generations
all_ids = gen0_ids + gen1_ids + gen2_ids

#Write the .vcf with individuals from the last three generations
with open("gens_0_1_2.vcf", "w") as vcffile:
	mutated_trees.write_vcf(vcffile,
	individuals = all_gens,
	individual_names = all_ids)


### Make a table with information listing each individual's parents and subpopulation

#Make an empty dictionary to hold information about each individual
#In the dictionary, the individual pedigree ID is the key,
#and the values, in order, are the node numbers of its genome 1 and genome 2,
#pedigree IDs of parents 1 and 2, subpopulation the individual belongs to,
#And the generations ago the individual was born in
ind_info_dict = {}

#Create a second dictionary where the keys are genome IDs and values are pedigree IDs,
#to be used to replace genome IDs in the pandas data frame below with subpop. of origin
#of coalescent tree
replace_inds_dict = {}
for i in all_gens:
#for i in pyslim.individuals_alive_at(slim_trees, 0):
	ind = slim_trees.individual(i)
	if ind.metadata["pedigree_id"] not in ind_info_dict:
		ind_info_dict[str(ind.metadata["pedigree_id"])] = [str(ind.nodes[0]), str(ind.nodes[1]), str(ind.metadata["pedigree_p1"]), str(ind.metadata["pedigree_p2"]), str(ind.metadata["subpopulation"])]
		
		#Add a column saying which generation the individual is from
		#Gen == 0 are offspring, gen == 1 are parents, gen == 2 are grandparents
		if str(ind.metadata["pedigree_id"]) in gen0_ids:
			ind_info_dict[str(ind.metadata["pedigree_id"])].append("0")
		
		elif str(ind.metadata["pedigree_id"]) in gen1_ids:
			ind_info_dict[str(ind.metadata["pedigree_id"])].append("1")
		
		elif str(ind.metadata["pedigree_id"]) in gen2_ids:
			ind_info_dict[str(ind.metadata["pedigree_id"])].append("2")

	replace_inds_dict[ind.nodes[0]] = ind.metadata["pedigree_id"]
	replace_inds_dict[ind.nodes[1]] = ind.metadata["pedigree_id"]





#Write the individual information to a .csv
#Pedigree.ID for first column isn't labeled, so must go in and manually add
(pd.DataFrame.from_dict(data = ind_info_dict, orient = "index", columns = ["Node.Num.Genome.1", "Node.Num.Genome.2", "Parent.1.ID", "Parent.2.ID", "Subpopulation.ID", "Gens.Ago.Born"])
   .to_csv("Individual_Pedigree_Info_full_genome_new.csv"))

print("Now parsing trees to determine populations-of-origin for each coalescent tree")

#Use tspop to get ancestry population of each coalescent tree, per haploid genome

#Make sure "census_time" is right before gene flow started, and matches with the SLiM model
tspop_anc_table = tspop.get_pop_ancestry(mutated_trees, census_time=30.01)

#A table listing genome ID, left and right bounds of each coalescent tree,
#ancestor of that segment, and population of origin of that segment
anc_table = tspop_anc_table.ancestry_table

#Can get more information about ancestry here
squashed_table = tspop_anc_table.squashed_table

#Remove the ancestral individuals that started the simulation and aren't needed
#anc_table.drop(anc_table.index[:num_genomes+1], inplace=True)

#Make a copy of the ancestry table so we can find and replace genome IDs with pedigree IDs
anc_table_ind_ids = anc_table.copy(deep=False)

#Find and replace genome IDs with pedigree IDs
anc_table_ind_ids['sample'] = anc_table_ind_ids['sample'].map(replace_inds_dict).infer_objects(copy=False)

#Change column types so values can be used for searching below
anc_table_ind_ids['sample'] = anc_table_ind_ids['sample'].astype(str)

```

## Eric working some of his code in here

To be honest, I think that the squashed table is what we really want---I believe
that the squashed table is made by smushing together adjacent segments in which
the pop-origins have not changed smushed together.  So, it has fewer segments
but no loss of information, I think

```{r}
squash_tib <- as_tibble(py$squashed_table)
squash_tib
```

Now, I think we should be able to join individual information onto these nodes.
I just throw in some code to make tibbles out of that.
```{python}

# set ts, because that is what I used in all the expressions below...
ts = mutated_trees


node_ids = np.array([n.id for n in ts.nodes() ])  # tskit ids of the nodes
node_pops = ts.nodes_population                # pops that the nodes belong to
node_indivs = ts.nodes_individual     # indivs that the nodes belong to
node_times = ts.nodes_time    # times that the nodes occur at



ind_ids = np.array([i.id for i in ts.individuals() ]) # get the tskit ids of the individuals
ind_pops = ts.individuals_population          # pops that the individuals belong to
ind_times = ts.individual_times          # times that are associated with the individuals

# metadata from the individuals
ind_pedigree_ids = np.array([i.metadata["pedigree_id"] for i in ts.individuals() ])
ind_pedigree_p1 = np.array([i.metadata["pedigree_p1"] for i in ts.individuals() ])
ind_pedigree_p2 = np.array([i.metadata["pedigree_p2"] for i in ts.individuals() ])
ind_sex = np.array([i.metadata["sex"] for i in ts.individuals() ])


```


Now, we can make a nodes tibble and an indivs tibble for easier viewing and
subsequent handling of all this in R
```{r}
indiv_tib <- tibble(
  ind_id = as.integer(py$ind_ids),
  ind_pop = as.integer(py$ind_pops),
  ind_time = as.double(py$ind_times),
  sex = as.integer(py$ind_sex),
  ped_id = as.integer(py$ind_pedigree_ids),
  ped_p1 = as.integer(py$ind_pedigree_p1),
  ped_p2 = as.integer(py$ind_pedigree_p2)
)

nodes_tib <- tibble(
  node_id = as.integer(py$node_ids),
  node_pop = as.integer(py$node_pops),
  node_ind = as.integer(py$node_indivs),
  node_time = as.integer(py$node_times)
)
```

Now we can left_join these onto the squash tib to check in on when
these samples existed and confirm we have the right fish in there.

```{r}
squash2 <- squash_tib %>%
  rename(sample_node = sample) %>%
  left_join(nodes_tib, by = join_by(sample_node == node_id)) %>%
  left_join(indiv_tib, by = join_by(node_ind == ind_id))
squash2
```

That is looking quite promising.  

Let's count the number of distinct nodes in each different time:
```{r}
squash2 %>%
  group_by(node_time, ind_time, node_pop, sex) %>%
  summarise(
    num_distinct_nodes = n_distinct(sample_node),
    num_distinct_indivs = n_distinct(node_ind)
  )
```

So, the founders in time 30 are still in there, because I didn't remove them from
the squash tib the way Jared did, but it would be easy to do so now, and while we are
at it, we will also create x positions for the different nodes in different times and
pops, and also compute an admixture score
```{r}
squash012 <- squash2 %>%
  filter(node_time <= 2) %>%
  group_by(sample_node) %>%
  mutate(admixture_score = sum((right - left) * (population - 1))) %>%
  ungroup() %>%
  arrange(node_time, node_pop, admixture_score) %>%
  group_by(node_time, node_pop) %>%
  mutate(node_x = as.integer(factor(sample_node, levels = unique(sample_node))))
```

Now, we can have a look at the segments on these haplotypes.
```{r}
ggplot(squash012) +
  geom_rect(aes(xmin = node_x - 1, xmax = node_x, ymin = left, ymax = right, fill = factor(population))) +
  facet_grid(node_time ~ node_pop)
```


Aha!  That is something I saw when playing with `link_ancestors()`---the problem is that
the samples are included as possible ancestors if they are have been remembered in the
tree sequence.  There might be an option in tspop to get around that.  If not, you
can just do each cohort separately (that is what I ended up doing with 
link_ancestors).  The problem is that if a sample node from the previous generation
is present amongst the samples, then `link_ancestors()` will only trace the ancestry
back to that single previous generation and find the pop that that individual
is in.  That is why generations 0 and 1 look so monolithic---because they all
trace back to an individual in generation 1 or 2 and the "ancestral" pop is taken
to be where that individual was in generation 1 or 2.  Clearly not what
we want.  

**Update:** I had hoped that we could just run `tspop.get_pop_ancestry()` on each
different cohort, but that does not seem easily done.  So, we will have to
roll our own---which is too bad, because tspop is quite tidy and clean,
but we could also wrap this all up into a single R function eventually.  

Not tonight, though!  

## Coming back to this to extract the ancestors

Now I have an R package that will do this:
```{r}
library(MixedUpSlimSims)
```

First we must get a summary of the nodes and indivdiuals:
```{r}
ni <- ts_nodes_and_inds(py$slim_trees)
```

Now we can figure out who our sample nodes and ancestral/founder nodes are
```{r}
founder_nodes <- ni$nodes_tib %>%
  filter(node_time == 30) %>%
  pull(node_id)
founder_node_pops <- ni$nodes_tib %>%
  filter(node_time == 30) %>%
  pull(node_pop)
```
And then make a list of the focal (sample) nodes in years 0, 1, 2
```{r}
focal_nodes_list <- lapply(0:2, function(x) {
  ni$nodes_tib %>%
    filter(node_time == x & node_pop == 2) %>%
    pull(node_id)
})
```


Now, we can get the ancestral segments at all those focal nodes:

```{r}
segments_tib <- ancestral_segs(
  ts = py$mutated_trees,
  focal_nodes_list = focal_nodes_list,
  founder_nodes = founder_nodes,
  nodes_tib = ni$nodes_tib,
  indiv_tib = ni$indiv_tib
)
```


And then we can get the ancestral tracts in the individuals that those nodes belong to.
```{r}
ind_tracts <- indiv_ancestry_tracts(segments_tib)
```
Now make a plot:
```{r}
#| fig-height: 17
ind_segs3 <- ind_tracts %>%
  mutate(
    time_f = factor(ind_time, levels = 2:0)
  ) %>%
  group_by(ind_id) %>%
  mutate(admixture_1_score = sum( (right - left) * dose)) %>%
  ungroup() %>%
  arrange(time_f, admixture_1_score, ind_id) %>%
  group_by(time_f) %>%
  mutate(
    ind_int = as.integer(factor(ind_id, levels = unique(ind_id))),
    dose_c = as.character(dose)
  )


# this is Omyk_v1.0.  We
fai <- read_tsv(
  "inputs/omyV6Chr.fasta.fai",
  col_names = c("chrom", "len", "cumul", "X1", "X2")
) %>%
  mutate(
    ends = cumsum(len)
  )

ggplot(ind_segs3) +
  geom_rect(aes(xmin = ind_int - 1, xmax = ind_int, ymin = left, ymax = right, fill = dose_c)) +
  facet_wrap(~ time_f, ncol = 1) +
  scale_fill_manual(values = c(`2` = "red", `3` = "orange", `4` = "blue")) +
  geom_hline(yintercept = fai$ends, linewidth = 0.05)

```
